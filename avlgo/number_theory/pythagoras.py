from math import sqrt

from avlgo.number_theory.coprimes import is_coprimes


def is_pythagorean_triple(a, b, c):
    """
    Check whether (a, b, c) is a Pythagorean triple.

    Time Complexity: O(1)
    Space Complexity: O(1)

    :type a: int
    :type b: int
    :type c: int
    :rtype: bool
    """
    return a ** 2 + b ** 2 == c ** 2


def primitive_pythagorean_triple(m, n):
    """
    Generate a new primitive Pythagorean triple based on 2 seed numbers.
    NOTE: m, n must be coprime, and exactly one of them is even.

    Time Complexity: O(1)
    Space Complexity: O(1)

    :type m: int
    :type n: int
    :return: (a, b, c) primitive Pythagorean triple where 0 < a < b < c
    """
    # All primitive Pythagorean triples can be generated by:
    # a = m ^ 2 - n ^ 2, b = 2mn, c = m ^ 2 + n ^ 2
    # where m > n > 0 and m, n are coprime, and exactly one of them is even.
    m_2 = m ** 2
    n_2 = n ** 2
    a, b, c = m_2 - n_2, 2 * m * n, m_2 + n_2
    return (a, b, c) if a < b else (b, a, c)


def primitive_pythagorean_triples_by_perimeter(perimeter):
    """
    Generate all primitive Pythagorean triples with maximal given perimeter.

    Time Complexity: O(P * log(P))
    Space Complexity: O(1)

    :param perimeter: maximal possible triangle perimeter.
    :type perimeter: int
    :return: generator of all (a, b, c) primitive Pythagorean triple where 0 < a < b < c, a + b + c <= P
    :rtype: tuple[int, int, int]
    """
    # Generate a = m ^ 2 - n ^ 2, b = 2mn, c = m ^ 2 + n ^ 2, so P = 2m(m+n) < 2m^2
    m_limit = int(sqrt(perimeter / 2)) + 1
    for m in range(2, m_limit):
        # exactly one of m, n, must be even
        for n in range(1 + m % 2, m, 2):
            if 2 * m * (m + n) > perimeter:
                # m, n are consecutive increasing
                break
            if not is_coprimes(m, n):
                continue

            yield primitive_pythagorean_triple(m, n)


def primitive_pythagorean_triples_by_hypotenuse(hypotenuse):
    """
    Generate all primitive Pythagorean triples with maximal given perimeter.

    Time Complexity: O(H * log(H))
    Space Complexity: O(1)

    :param hypotenuse: maximal possible triangle hypotenuse.
    :type hypotenuse: int
    :return: generator of all (a, b, c) primitive Pythagorean triple where 0 < a < b < c < H
    :rtype: tuple[int, int, int]
    """
    # Generate a = m ^ 2 - n ^ 2, b = 2mn, c = m ^ 2 + n ^ 2 < m ^ 2
    m_limit = int(sqrt(hypotenuse)) + 1
    for m in range(2, m_limit):
        # exactly one of m, n, must be even
        for n in range(1 + m % 2, m, 2):
            if m ** 2 + n ** 2 > hypotenuse:
                # m, n are consecutive increasing
                break
            if not is_coprimes(m, n):
                continue

            yield primitive_pythagorean_triple(m, n)
